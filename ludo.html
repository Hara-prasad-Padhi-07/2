<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Ludo Pro â€“ Animated, Themed, Sound, Avatars</title>
<style>
  /* ===== THEME SYSTEM ===== */
  :root{
    --bg:#111;
    --text:#fff;
    --panel:#1a1a1a;
    --board:#f7f7f7;
    --track:#ffffff;
    --line:#dcdcdc;
    --safe:#95a5a6;
    --center:#ffffff;

    --red:#e74c3c;
    --green:#27ae60;
    --yellow:#f1c40f;
    --blue:#3498db;

    --accent:#fff;
    --shadow: rgba(0,0,0,.35);
    --texture-opacity: .08;
  }
  /* Neon theme */
  .theme-neon{
    --bg:#0b0f1a;
    --text:#e8f6ff;
    --panel:#0f1424;
    --board:#0c1220;
    --track:#0f1a33;
    --line:#1f2b4a;
    --safe:#7f8fa6;
    --center:#0f1424;

    --red:#ff4d6d;
    --green:#2ecc71;
    --yellow:#ffd166;
    --blue:#4dabf7;

    --accent:#a5d8ff;
    --shadow: rgba(0,0,0,.5);
    --texture-opacity:.18;
  }
  /* Pastel theme */
  .theme-pastel{
    --bg:#f6f7fb;
    --text:#2b2d42;
    --panel:#ffffff;
    --board:#ffffff;
    --track:#f9fafc;
    --line:#e6e8ef;
    --safe:#b0bec5;
    --center:#ffffff;

    --red:#ff8a7a;
    --green:#7ee2a8;
    --yellow:#ffe58a;
    --blue:#8fd0ff;

    --accent:#2b2d42;
    --shadow: rgba(0,0,0,.15);
    --texture-opacity:.06;
  }

  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    background:var(--bg);
    color:var(--text);
    display:flex;
    min-height:100vh;
    align-items:center;
    justify-content:center;
  }
  .app{
    width:min(94vw,1080px);
    display:grid;
    grid-template-columns: 1fr 360px;
    gap:16px;
    align-items:start;
  }
  @media (max-width:1000px){
    .app{grid-template-columns:1fr}
  }

  /* ===== BOARD ===== */
  .board{
    background:var(--board);
    border-radius:16px;
    padding:12px;
    box-shadow:0 10px 30px var(--shadow);
    position:relative;
    overflow:hidden;
  }
  /* Optional subtle texture */
  .board.texture::before{
    content:"";
    position:absolute; inset:0;
    background:
      radial-gradient(circle at 20% 30%, rgba(255,255,255,var(--texture-opacity)) 0 12%, transparent 13%),
      radial-gradient(circle at 80% 70%, rgba(0,0,0,var(--texture-opacity)) 0 10%, transparent 11%);
    pointer-events:none;
  }
  .grid{
    display:grid;
    grid-template-columns: repeat(15, 1fr);
    grid-template-rows: repeat(15, 1fr);
    aspect-ratio:1/1;
    gap:2px;
  }
  .cell{
    background:var(--track);
    border:1px solid var(--line);
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
  }

  /* Home quadrants */
  .home{
    background:#fff;
    border:2px solid var(--line);
  }
  .home.red{background:linear-gradient(135deg,var(--red) 0%, #ffb3a8 100%)}
  .home.green{background:linear-gradient(135deg,var(--green) 0%, #baf3d3 100%)}
  .home.yellow{background:linear-gradient(135deg,var(--yellow) 0%, #fff1b8 100%)}
  .home.blue{background:linear-gradient(135deg,var(--blue) 0%, #bfe4ff 100%)}

  /* Token styling */
  .token{
    width:70%;
    height:70%;
    border-radius:50%;
    border:3px solid rgba(0,0,0,.2);
    box-shadow: inset 0 6px 12px rgba(255,255,255,.35), 0 6px 12px rgba(0,0,0,.25);
    cursor:pointer;
    transition:transform .15s ease, box-shadow .15s ease, outline .15s ease;
    outline:3px solid transparent;
    position:relative;
    z-index:2;
  }
  .token.red{background:var(--red)}
  .token.green{background:var(--green)}
  .token.yellow{background:var(--yellow)}
  .token.blue{background:var(--blue)}
  .token.disabled{cursor:not-allowed; opacity:.65}
  .token.selectable{outline:3px dashed var(--accent); transform:scale(1.03)}
  .token.moving{animation: bob .35s ease-in-out infinite alternate}
  @keyframes bob{to{transform:translateY(-2px)}}

  /* Safe star */
  .safe{
    position:absolute;inset:auto 6px 6px auto;
    width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;
    border-bottom:18px solid var(--safe);
    transform:rotate(35deg);
  }
  .safe.hidden{display:none}

  /* Home path highlight */
  .home-path{
    background: repeating-linear-gradient(
      45deg,
      rgba(0,0,0,.04),
      rgba(0,0,0,.04) 6px,
      rgba(255,255,255,.6) 6px,
      rgba(255,255,255,.6) 12px
    );
  }

  /* Center goal */
  .center{
    background:var(--center);
    border:3px solid #eee;
    display:flex;align-items:center;justify-content:center;
    font-weight:900;color:#333;letter-spacing:.6px;
  }

  /* ===== SIDE PANEL ===== */
  .panel{
    background:var(--panel);
    border-radius:16px;
    padding:16px;
    box-shadow:0 10px 30px var(--shadow);
  }
  .topbar{
    display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-bottom:12px;
  }
  .turn{
    font-weight:800;letter-spacing:.2px;display:flex;align-items:center;gap:8px;
  }
  .dot{
    width:12px;height:12px;border-radius:50%;
  }
  .dot.red{background:var(--red)}
  .dot.green{background:var(--green)}
  .dot.yellow{background:var(--yellow)}
  .dot.blue{background:var(--blue)}

  .dice{
    width:84px;height:84px;
    background:#fff;border-radius:12px;
    display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);
    gap:6px;padding:10px;border:3px solid #eee;
    box-shadow:0 6px 16px rgba(0,0,0,.25);
  }
  .pip{width:14px;height:14px;border-radius:50%;background:#333;margin:auto;visibility:hidden}

  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  button{
    background:#fff;color:#111;border:none;border-radius:10px;
    padding:10px 14px;font-weight:700;cursor:pointer;
    box-shadow:0 6px 12px rgba(0,0,0,.25);
  }
  button:disabled{opacity:.6;cursor:not-allowed}
  select, .toggle{
    background:#fff;color:#111;border:none;border-radius:10px;
    padding:10px 12px;font-weight:700;
    box-shadow:0 6px 12px rgba(0,0,0,.25);
  }
  .toggle{display:flex;align-items:center;gap:8px}

  .players{
    margin-top:12px;display:grid;grid-template-columns:1fr;gap:8px;
  }
  .player{
    background:#121212;border-radius:12px;padding:10px;display:flex;align-items:center;gap:10px;
  }
  .avatar{
    width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;
    font-size:22px;background:#fff;color:#111;border:2px solid #eee;
  }
  .pinfo{flex:1}
  .pname{font-weight:800;margin-bottom:4px}
  .pscore{font-size:.95rem;color:#ddd}
  .editname{
    background:#fff;color:#111;border:none;border-radius:8px;padding:6px 8px;font-weight:700;margin-left:8px;
  }

  .log{
    margin-top:12px;background:#121212;border-radius:12px;padding:10px;
    max-height:240px;overflow:auto;font-size:.95rem;
  }
  .log p{margin:.4rem 0;color:#ddd}

  .banner{
    margin-top:12px;background:#fff;color:#111;border-radius:12px;padding:12px;font-weight:900;text-align:center;display:none;
  }
  .banner.show{display:block}
</style>
</head>
<body class="theme-classic">
<div class="app">
  <div class="board texture" id="board">
    <div id="grid" class="grid"></div>
  </div>

  <div class="panel">
    <div class="topbar">
      <div class="turn">Turn: <span id="turnName">Red</span> <span id="turnDot" class="dot red"></span></div>
      <div id="dice" class="dice" aria-label="Dice">
        <div class="pip"></div><div class="pip"></div><div class="pip"></div>
        <div class="pip"></div><div class="pip"></div><div class="pip"></div>
        <div class="pip"></div><div class="pip"></div><div class="pip"></div>
      </div>
    </div>

    <div class="controls">
      <button id="rollBtn">Roll dice</button>
      <button id="resetBtn">Reset</button>
      <select id="themeSelect" title="Theme">
        <option value="theme-classic">Classic</option>
        <option value="theme-neon">Neon</option>
        <option value="theme-pastel">Pastel</option>
      </select>
      <label class="toggle"><input type="checkbox" id="toggleSafe" checked/> Show safe icons</label>
      <label class="toggle"><input type="checkbox" id="toggleTexture" checked/> Board texture</label>
    </div>

    <div class="players" id="playersPanel"></div>

    <div class="log" id="log"></div>
    <div class="banner" id="banner"></div>
  </div>
</div>

<script>
/* ====== CONFIG ====== */
const COLORS = ["red","green","yellow","blue"];
const AVATARS = { red:"â¤ï¸", green:"ðŸ€", yellow:"â­", blue:"ðŸ’™" };
const DEFAULT_NAMES = { red:"Red", green:"Green", yellow:"Yellow", blue:"Blue" };

const gridEl = document.getElementById("grid");
const logEl = document.getElementById("log");
const rollBtn = document.getElementById("rollBtn");
const resetBtn = document.getElementById("resetBtn");
const turnNameEl = document.getElementById("turnName");
const turnDotEl = document.getElementById("turnDot");
const diceEl = document.getElementById("dice");
const playersPanelEl = document.getElementById("playersPanel");
const bannerEl = document.getElementById("banner");
const themeSelectEl = document.getElementById("themeSelect");
const toggleSafeEl = document.getElementById("toggleSafe");
const toggleTextureEl = document.getElementById("toggleTexture");
const boardEl = document.getElementById("board");

let currentPlayerIndex = 0;
let diceValue = null;
let rolling = false;

/* ====== AUDIO (Web Audio API) ====== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playTone(freq=440, dur=0.18, type="sine", gain=0.08){
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  g.gain.value = gain;
  osc.connect(g).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + dur);
}
function diceSound(){
  // soft rattles
  playTone(220,0.08,"triangle",0.05);
  setTimeout(()=>playTone(330,0.08,"triangle",0.05),60);
  setTimeout(()=>playTone(180,0.06,"triangle",0.05),120);
}
function captureSound(){
  playTone(220,0.12,"sawtooth",0.08);
  setTimeout(()=>playTone(180,0.12,"sawtooth",0.07),120);
}
function goalSound(){
  playTone(523.25,0.16,"sine",0.08);
  setTimeout(()=>playTone(659.25,0.16,"sine",0.08),180);
  setTimeout(()=>playTone(783.99,0.22,"sine",0.08),360);
}

/* ====== GRID ====== */
const cells = [];
for(let r=0;r<15;r++){
  for(let c=0;c<15;c++){
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.dataset.r = r;
    cell.dataset.c = c;
    gridEl.appendChild(cell);
    cells.push(cell);
  }
}
function cellAt(r,c){ return cells[r*15 + c]; }

/* Homes */
function paintHomes(){
  for(let r=0;r<4;r++) for(let c=0;c<4;c++) cellAt(r,c).classList.add("home","red");
  for(let r=0;r<4;r++) for(let c=11;c<15;c++) cellAt(r,c).classList.add("home","green");
  for(let r=11;r<15;r++) for(let c=0;c<4;c++) cellAt(r,c).classList.add("home","yellow");
  for(let r=11;r<15;r++) for(let c=11;c<15;c++) cellAt(r,c).classList.add("home","blue");
}
paintHomes();

/* Center goal */
for(let r=6;r<=8;r++){
  for(let c=6;c<=8;c++){
    cellAt(r,c).classList.add("center");
    cellAt(r,c).textContent = "GOAL";
  }
}

/* Track (52 tiles) */
const TRACK = [
  [6,0],[6,1],[6,2],[6,3],[6,4],[6,5],
  [5,6],[4,6],[3,6],[2,6],[1,6],[0,6],
  [0,7],[0,8],[0,9],[0,10],[0,11],[0,12],
  [1,13],[2,13],[3,13],[4,13],[5,13],[6,13],
  [6,14],[7,14],[8,14],[9,14],[10,14],[11,14],
  [12,13],[13,13],[14,13],[14,12],[14,11],[14,10],
  [13,9],[12,9],[11,9],[10,9],[9,9],[8,9],
  [8,8],[8,7],[8,6],[8,5],[8,4],[8,3],
  [7,2],[6,2],[5,2],[4,2]
];
TRACK.forEach(([r,c])=> cellAt(r,c).style.background = "#fff");

/* Safe tiles */
const SAFE_INDEXES = new Set([0,8,13,21,26,34,39,47]);
SAFE_INDEXES.forEach(i=>{
  const [r,c] = TRACK[i];
  const star = document.createElement("div");
  star.className = "safe";
  cellAt(r,c).appendChild(star);
});

/* Home paths (5 tiles to center) */
const HOME_PATH = {
  red:   [[7,0],[7,1],[7,2],[7,3],[7,4]],
  green: [[0,7],[1,7],[2,7],[3,7],[4,7]],
  yellow:[[14,7],[13,7],[12,7],[11,7],[10,7]],
  blue:  [[7,14],[7,13],[7,12],[7,11],[7,10]]
};
Object.values(HOME_PATH).flat().forEach(([r,c])=> cellAt(r,c).classList.add("home-path"));

/* Home slots */
const HOME_SLOTS = {
  red:   [[1,1],[1,2],[2,1],[2,2]],
  green: [[1,12],[1,13],[2,12],[2,13]],
  yellow:[[12,1],[12,2],[13,1],[13,2]],
  blue:  [[12,12],[12,13],[13,12],[13,13]]
};

/* Start & entry indexes */
const START_INDEX = { red:0, green:13, yellow:26, blue:39 };
const HOME_ENTRY_INDEX = { red:50, green:11, yellow:24, blue:37 };

/* ====== STATE ====== */
const players = COLORS.map(color=>({
  color,
  name: DEFAULT_NAMES[color],
  score: 0,
  tokens: Array.from({length:4}).map((_,i)=>({
    id: `${color}-${i}`,
    state: "home", // home | track | homePath | goal
    trackIndex: null,
    homeIndex: null,
    element: null
  }))
}));

/* ====== UI HELPERS ====== */
function log(msg){
  const p = document.createElement("p");
  p.textContent = msg;
  logEl.prepend(p);
}
function updateTurnUI(){
  const color = COLORS[currentPlayerIndex];
  turnNameEl.textContent = players[currentPlayerIndex].name;
  turnDotEl.className = `dot ${color}`;
}
function renderDice(value){
  const patterns = {
    1: [[1,1]],
    2: [[0,0],[2,2]],
    3: [[0,0],[1,1],[2,2]],
    4: [[0,0],[0,2],[2,0],[2,2]],
    5: [[0,0],[0,2],[1,1],[2,0],[2,2]],
    6: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,2]]
  };
  const pips = diceEl.querySelectorAll(".pip");
  pips.forEach(p=> p.style.visibility="hidden");
  if(!value) return;
  patterns[value].forEach(([r,c])=>{
    pips[r*3 + c].style.visibility = "visible";
  });
}

/* ====== RENDER TOKENS ====== */
function renderInitialTokens(){
  players.forEach(p=>{
    p.tokens.forEach((t,i)=>{
      const [r,c] = HOME_SLOTS[p.color][i];
      const el = document.createElement("div");
      el.className = `token ${p.color}`;
      el.dataset.id = t.id;
      cellAt(r,c).appendChild(el);
      t.element = el;
    });
  });
}
renderInitialTokens();

/* ====== PLAYER PANEL ====== */
function renderPlayersPanel(){
  playersPanelEl.innerHTML = "";
  players.forEach((p,idx)=>{
    const row = document.createElement("div");
    row.className = "player";
    const avatar = document.createElement("div");
    avatar.className = "avatar";
    avatar.textContent = AVATARS[p.color];
    const info = document.createElement("div");
    info.className = "pinfo";
    const name = document.createElement("div");
    name.className = "pname";
    name.textContent = p.name;
    const score = document.createElement("div");
    score.className = "pscore";
    score.textContent = `Score: ${p.score}`;
    info.appendChild(name); info.appendChild(score);

    const edit = document.createElement("button");
    edit.className = "editname";
    edit.textContent = "Edit name";
    edit.addEventListener("click",()=>{
      const newName = prompt("Enter player name:", p.name);
      if(newName && newName.trim()){
        p.name = newName.trim();
        renderPlayersPanel();
        updateTurnUI();
      }
    });

    row.appendChild(avatar);
    row.appendChild(info);
    row.appendChild(edit);
    playersPanelEl.appendChild(row);

    // Highlight current player
    if(idx===currentPlayerIndex){
      row.style.outline = `3px solid var(--${p.color})`;
    }else{
      row.style.outline = "none";
    }
  });
}
renderPlayersPanel();

/* ====== HELPERS ====== */
function isSafeIndex(idx){ return SAFE_INDEXES.has(idx); }
function nextIndex(idx, steps){ return (idx + steps) % TRACK.length; }
function placeTokenAt(token, r, c){
  const el = token.element;
  const parent = el.parentElement;
  if(parent) parent.removeChild(el);
  cellAt(r,c).appendChild(el);
}
function tokensAtTrackIndex(idx){
  const [r,c] = TRACK[idx];
  const tokens = [];
  players.forEach(p=>{
    p.tokens.forEach(t=>{
      if(t.state==="track" && t.trackIndex===idx) tokens.push(t);
    });
  });
  return tokens;
}

/* ====== CAPTURE ====== */
function tryCaptureAt(idx, moverColor){
  const occupants = tokensAtTrackIndex(idx);
  occupants.forEach(t=>{
    if(t.state==="track" && t.trackIndex===idx){
      const safe = isSafeIndex(idx);
      const ownerColor = t.id.split("-")[0];
      if(!safe && ownerColor !== moverColor){
        // send back to home
        t.state = "home";
        t.trackIndex = null;
        t.homeIndex = null;
        const owner = players.find(p=>p.color===ownerColor);
        const i = parseInt(t.id.split("-")[1],10);
        const [hr,hc] = HOME_SLOTS[owner.color][i];
        placeTokenAt(t, hr, hc);
        log(`${players.find(p=>p.color===moverColor).name} captured ${owner.name}'s token!`);
        captureSound();
      }
    }
  });
}

/* ====== MOVEMENT (ANIMATED STEP-BY-STEP) ====== */
async function animateTrackMove(token, steps){
  token.element.classList.add("moving");
  let idx = token.trackIndex;
  for(let s=0;s<steps;s++){
    idx = nextIndex(idx,1);
    const [r,c] = TRACK[idx];
    placeTokenAt(token, r, c);
    await wait(140); // short delay per step
  }
  token.trackIndex = idx;
  token.element.classList.remove("moving");
  tryCaptureAt(idx, token.id.split("-")[0]);
}
function wait(ms){ return new Promise(res=> setTimeout(res, ms)); }

/* ====== MOVE TOKEN ====== */
function canEnterTrack(token){ return diceValue === 6 && token.state === "home"; }
function moveToken(player, token){
  const color = player.color;

  // Enter track
  if(canEnterTrack(token)){
    token.state = "track";
    token.trackIndex = START_INDEX[color];
    const [r,c] = TRACK[token.trackIndex];
    placeTokenAt(token, r, c);
    tryCaptureAt(token.trackIndex, color);
    return true;
  }

  // Move along track
  if(token.state === "track"){
    const entry = HOME_ENTRY_INDEX[color];
    // If landing exactly on home entry, convert to home path index 0
    const target = nextIndex(token.trackIndex, diceValue);
    if(target === entry){
      token.state = "homePath";
      token.trackIndex = null;
      token.homeIndex = 0;
      const [hr,hc] = HOME_PATH[color][0];
      placeTokenAt(token, hr, hc);
      return true;
    }else{
      // animate step-by-step
      return animateTrackMove(token, diceValue).then(()=>true);
    }
  }

  // Move inside home path (exact finish)
  if(token.state === "homePath"){
    const remaining = 5 - token.homeIndex;
    if(diceValue > remaining) return false;
    const nextIndexHP = token.homeIndex + diceValue;
    if(nextIndexHP === 5){
      token.state = "goal";
      token.homeIndex = 5;
      placeTokenAt(token, 7,7);
      player.score += 1;
      renderPlayersPanel();
      log(`${player.name} token reached GOAL!`);
      goalSound();
      return true;
    }else{
      token.homeIndex = nextIndexHP;
      const [hr,hc] = HOME_PATH[color][token.homeIndex];
      token.element.classList.add("moving");
      placeTokenAt(token, hr, hc);
      setTimeout(()=> token.element.classList.remove("moving"), 160);
      return true;
    }
  }

  return false;
}

/* ====== SELECTABLE TOKENS ====== */
function updateSelectableTokens(){
  const player = players[currentPlayerIndex];
  player.tokens.forEach(t=>{
    t.element.classList.remove("disabled","selectable");
  });

  const selectable = player.tokens.filter(t=>{
    if(t.state==="home") return diceValue===6;
    if(t.state==="track") return true;
    if(t.state==="homePath"){
      const remaining = 5 - t.homeIndex;
      return diceValue <= remaining;
    }
    return false;
  });

  player.tokens.forEach(t=>{
    if(!selectable.includes(t)) t.element.classList.add("disabled");
    else t.element.classList.add("selectable");
  });

  return selectable;
}

/* ====== CLICK HANDLER ====== */
gridEl.addEventListener("click",(e)=>{
  const tokenEl = e.target.closest(".token");
  if(!tokenEl || diceValue===null) return;
  const id = tokenEl.dataset.id;
  const color = id.split("-")[0];
  const player = players[currentPlayerIndex];
  if(player.color !== color) return;

  const token = player.tokens.find(t=>t.id===id);
  const movedPromise = moveToken(player, token);

  Promise.resolve(movedPromise).then((moved)=>{
    if(moved){
      const extraTurn = diceValue===6;
      diceValue = null;
      renderDice(null);
      player.tokens.forEach(t=> t.element.classList.remove("disabled","selectable"));

      // Win check (all 4 tokens at goal)
      const allGoal = player.tokens.every(t=>t.state==="goal");
      if(allGoal){
        bannerEl.textContent = `${player.name} wins the game! ðŸŽ‰`;
        bannerEl.classList.add("show");
        log(`${player.name} wins the game!`);
        rollBtn.disabled = true;
        return;
      }

      if(!extraTurn){
        currentPlayerIndex = (currentPlayerIndex+1) % COLORS.length;
        updateTurnUI();
        renderPlayersPanel();
      }else{
        log(`${player.name} rolled 6 â€” extra turn!`);
      }
      rollBtn.disabled = false;
    }
  });
});

/* ====== DICE ROLL ====== */
rollBtn.addEventListener("click",()=>{
  if(rolling) return;
  rolling = true;
  rollBtn.disabled = true;

  diceSound();

  let ticks = 10;
  const anim = setInterval(()=>{
    const v = Math.floor(Math.random()*6)+1;
    renderDice(v);
    if(--ticks===0){
      clearInterval(anim);
      diceValue = v;
      log(`${players[currentPlayerIndex].name} rolled ${v}`);
      const selectable = updateSelectableTokens();
      if(selectable.length===0){
        log(`No valid moves for ${players[currentPlayerIndex].name}. Turn passes.`);
        diceValue = null;
        renderDice(null);
        currentPlayerIndex = (currentPlayerIndex+1) % COLORS.length;
        updateTurnUI();
        renderPlayersPanel();
        rollBtn.disabled = false;
      }
      rolling = false;
    }
  },60);
});

/* ====== RESET ====== */
resetBtn.addEventListener("click",()=>{
  players.forEach(p=>{
    p.score = 0;
    p.tokens.forEach((t,i)=>{
      t.state="home"; t.trackIndex=null; t.homeIndex=null;
      const [r,c] = HOME_SLOTS[p.color][i];
      placeTokenAt(t, r, c);
      t.element.classList.remove("disabled","selectable","moving");
    });
  });
  diceValue=null; renderDice(null);
  currentPlayerIndex=0; updateTurnUI();
  renderPlayersPanel();
  rollBtn.disabled=false;
  bannerEl.classList.remove("show");
  bannerEl.textContent = "";
  log("Game reset.");
});

/* ====== THEMES & TOGGLES ====== */
themeSelectEl.addEventListener("change",(e)=>{
  document.body.classList.remove("theme-classic","theme-neon","theme-pastel");
  document.body.classList.add(e.target.value);
});
toggleSafeEl.addEventListener("change",(e)=>{
  const show = e.target.checked;
  document.querySelectorAll(".safe").forEach(s=>{
    s.classList.toggle("hidden", !show);
  });
});
toggleTextureEl.addEventListener("change",(e)=>{
  boardEl.classList.toggle("texture", e.target.checked);
});

/* ====== INIT ====== */
updateTurnUI();
renderDice(null);
</script>
</body>
</html>